# 两个整数公有的倍数称为它们的公倍数，其中最小的一个正整数称为它们两个的最小公倍数。当然，n个数也可以有最小公倍数，例如：5，7，15的最小公倍数是105。
# 输入n个数，请计算它们的最小公倍数。
#
# 输入格式:
# 首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。
# 每组测试先输入一个整数n（2≤n≤20），再输入n个正整数（属于[1，100000]范围内）。这里保证最终的结果在int型范围内。
#
# 输出格式:
# 对于每组测试，输出n个整数的最小公倍数。
#
# 输入样例:
# 3
# 3 5 7 15
# 5 1 2 4 3 5
# 8 7 15 12 3 4 6 4 9
# 输出样例:
# 105
# 60
# # 1260两个整数公有的倍数称为它们的公倍数，其中最小的一个正整数称为它们两个的最小公倍数。当然，n个数也可以有最小公倍数，例如：5，7，15的最小公倍数是105。
# 输入n个数，请计算它们的最小公倍数。
#
# 输入格式:
# 首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。
# 每组测试先输入一个整数n（2≤n≤20），再输入n个正整数（属于[1，100000]范围内）。这里保证最终的结果在int型范围内。
#
# 输出格式:
# 对于每组测试，输出n个整数的最小公倍数。
#
# 输入样例:
# 3
# 3 5 7 15
# 5 1 2 4 3 5
# 8 7 15 12 3 4 6 4 9
# 输出样例:
# 105
# 60
# # 1260
def Least_common_multiple(a, b):  # 求最小公倍数
    max_num = max(a, b)
    for i in range(max_num, a*b+1):
        if i % a == 0 and i % b == 0:
            return i


t = int(input())
for i in range(t):
    n, *lst = map(int, input().split())
    lst2 = list(set(lst))  # 这种方式去重后顺序会变
    lst2.sort(key=lst.index)  # 这样可以保证顺序不变，对于此题顺序变不变无所谓
    j = 0

